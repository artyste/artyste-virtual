<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Artyste | Virtual</title>
	<!-- Babylon.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
	<!-- <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script> -->
	<!-- <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script> -->
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	<!-- <script src="https://cdn.babylonjs.com/loaders/babylonjs.glTFFileLoader.js"></script> -->
	<script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
	<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
	<script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

	<style>
		html,
		body {
			overflow: hidden;
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
		}

		#renderCanvas {
			width: 100%;
			height: 100%;
			touch-action: none;
		}
	</style>
</head>

<body>
	<canvas id="renderCanvas"></canvas>

	<script>
		// Get Variable from URL
		const queryString = window.location.search;
		const urlParams = new URLSearchParams(queryString);
		const gallery = urlParams.get('gallery');
		const url = 'https://api.artyste.info/v1/gallery/' + gallery;

		// JSON FETCH
		var getJson = async function () {
			var jsonData;
			await fetch(url)
				.then(response => response.json())
				.then(data => {
					jsonData = data;
				}
				);
			return jsonData;
		}

		// FINISH SCENE IMPORT
		var FinishSceneImport = function () {

		}

		//BJS
		var canvas = document.getElementById("renderCanvas");
		var engine = null;
		var scene = null;
		var sceneToRender = null;
		var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
		var camera = null;
		var sceneReady = false;
		var waterMat = null;


		var createScene = async function (jsonData) {

			var scene = new BABYLON.Scene(engine);
			scene.clearColor = BABYLON.Color3.Black();
			scene.debugLayer.show();

			camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1, -4), scene);
			// camera.setTarget(BABYLON.Vector3.Zero());
			camera.attachControl(false);
			camera.angularSensibility = 15000;
			camera.speed = 0.05;
			camera.minZ = 0.01;
			camera.keysUp = [38, 87];		//W
			camera.keysLeft = [37, 65];	//A
			camera.keysDown = [40, 83];	//S
			camera.keysRight = [39, 68];//D
			// camera.keysRotateLeft = [37];	//L
			// camera.keysRotateRight = [39];	//R
			const frameSize = 1.2;
			const frameScale = new BABYLON.Vector3(frameSize, frameSize, frameSize);

			var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, -1), scene);
			light.intensity = 0.8;

			const galleryIdx = jsonData.length - 1;
			const color1 = jsonData[galleryIdx].gallery.color1 != null ? new BABYLON.Color3.FromHEXString(jsonData[galleryIdx].gallery.color1) : BABYLON.Color3.White();
			const color2 = jsonData[galleryIdx].gallery.color2 != null ? new BABYLON.Color3.FromHEXString(jsonData[galleryIdx].gallery.color2) : BABYLON.Color3.Black();
			const color3 = jsonData[galleryIdx].gallery.color3 != null ? new BABYLON.Color3.FromHEXString(jsonData[galleryIdx].gallery.color3) : BABYLON.Color3.White();

			const virtID = jsonData[galleryIdx].gallery.virtual != null ? jsonData[galleryIdx].gallery.virtual : 1;

			// LOAD ARTS
			var arts = [];
			for (let i = 0; i < jsonData.length; i++) {
				if (i == jsonData.length - 1) { //gallery avatar&banner
					console.log(jsonData[i].gallery.name);

					const planeAvatar = BABYLON.MeshBuilder.CreatePlane("planeAvatar",
						{ height: 2, width: 2 });
					planeAvatar.position.x = 1;
					planeAvatar.position.y = 1;
					planeAvatar.position.z = 1.99;
					var matAvatar = new BABYLON.StandardMaterial("matAvatar", scene);
					var texAvatar = new BABYLON.Texture(jsonData[i].gallery.avatar, scene);
					matAvatar.diffuseTexture = texAvatar;
					matAvatar.speculartexture = texAvatar;
					planeAvatar.material = matAvatar;

					const planeBanner = BABYLON.MeshBuilder.CreatePlane("planeBanner",
						{ height: 1, width: 4 });
					planeBanner.position.x = 0;
					planeBanner.position.y = 2.5;
					planeBanner.position.z = 1.98;
					var matBanner = new BABYLON.StandardMaterial("matBanner", scene);
					var texBanner = new BABYLON.Texture(jsonData[i].gallery.banner, scene);
					matBanner.diffuseTexture = texBanner;
					matBanner.speculartexture = texBanner;
					let specColorPwr = 1;
					matBanner.specularPower = 50;
					matBanner.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
					planeBanner.material = matBanner;

				}
				else { //arts
					console.log(jsonData[i].title);
					// const planeArt = BABYLON.MeshBuilder.CreatePlane("planeArt",
					// 	{ height: 0.8, width: 0.8 });
					let planeArt = BABYLON.Mesh.CreateBox("planeArt", 1, scene);
					planeArt.scaling = new BABYLON.Vector3(1, 1, 0.002);
					planeArt.position.x = (i - (jsonData.length / 2)) * 1.5;
					planeArt.position.y = 0.5;
					planeArt.position.z = -0.5;
					planeArt.rotation = new BABYLON.Vector3(0.45 * Math.PI / 2, 0, 0);
					let frame = planeArt.clone();

					let matArt = new BABYLON.StandardMaterial("matArt", scene);
					let texArt = new BABYLON.Texture(jsonData[i].fileimage, scene, false, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, function () {
						var texSize = texArt.getSize();
						if (texSize.width != 0) { //malformed returns
							//Scaling ART & FRAME
							planeArt.scaling = new BABYLON.Vector3(1, texSize.height / texSize.width, 0.002);
							frame.scaling = planeArt.scaling;
							frame.scaling = frame.scaling.multiply(frameScale);
							frame.scaling.z = 0.02;
						}
					});
					matArt.diffuseTexture = texArt;
					matArt.speculartexture = texArt;
					var specColorPwr = 0.5;
					matArt.specularPower = 200;
					matArt.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
					planeArt.material = matArt;

					//FRAME
					frame.translate(BABYLON.Axis.Z, 10, BABYLON.Space.LOCAL);
					let matFrame = new BABYLON.StandardMaterial("matFrame", scene);
					matFrame.diffuseColor = color1;
					var specColorPwr = 0.3;
					matFrame.specularPower = 500;
					matFrame.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
					frame.material = matFrame;

				}
			}


			//LOAD MODELS
			// var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 1, segments: 4 }, scene);
			// sphere.position.y = 1;
			var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
			ground.visibility = 0;

			console.log("Virtual: " + virtID);

			if (virtID != null) {
				BABYLON.SceneLoader.ImportMesh("", "./models/", "virtual" + virtID.toString().padStart(2, '0') + ".babylon", scene, function (newMeshes) {
					newMeshes.forEach((mesh) => {
						// console.log(mesh.name);
						// console.log(mesh.position);

						// if (mesh.name.indexOf("Wall") > -1) {
						// 	mesh.translate(BABYLON.Axis.X, 5, BABYLON.Space.LOCAL);
						// }
						if (mesh.name.indexOf("glass") > -1) {

						}
						if (mesh.name.indexOf("aterFall") > -1) {
							//WATER
							
							mesh.visibility = false;
						}

					});

					// Skybox
					var skybox = BABYLON.Mesh.CreateBox("skyBox", 1000.0, scene);
					var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
					skyboxMaterial.backFaceCulling = false;
					skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("https://playground.babylonjs.com/textures/TropicalSunnyDay", scene);
					skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
					skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
					skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
					skyboxMaterial.disableLighting = true;
					skybox.material = skyboxMaterial;


					FinishSceneImport();
				});

			}
			else {
				BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/CornellBox/", "cornellBox.glb", scene, function (newMeshes) {
					newMeshes[0].rotationQuaternion = null;
					newMeshes[0].rotation.y = 0;
					scene.getMaterialByName("light.000").emissiveColor = BABYLON.Color3.White();

					/* lightmaps assignation */
					// we have to cycles through objects to assign their lightmaps
					const lightmappedMeshes = ["bloc.000", "suzanne.000", "cornellBox.000"];
					lightmappedMeshes.forEach((meshName) => {
						// lightmap texture creation
						let currentLightmap = new BABYLON.Texture(
							"https://models.babylonjs.com/CornellBox/" + meshName + ".lightmap.jpg",
							scene,
							null,
							false);
						currentLightmap.onLoadObservable.addOnce(function (tex) {
							currentLightmap.name = meshName + "-lightmap";
							newMeshes.forEach((mesh) => {
								if (mesh.name.indexOf(meshName) != -1) {
									mesh.material.lightmapTexture = currentLightmap;
									mesh.material.lightmapTexture.coordinatesIndex = 1;
									mesh.material.useLightmapAsShadowmap = true;
								}
							});
						});
					});

				});
			}

			//LOAD AUDIO
			var music = new BABYLON.Sound("music", "audio/music.mp3", scene, function () {
				console.log("music laoded!!");
				music.setPosition(new BABYLON.Vector3(0, 0, 2));
				music.play();
			}, {
				volume: 0.8,
				loop: true,
				// autoplay: true,
				spatialSound: true,
				distanceModel: "exponential",
				rolloffFactor: 0.4
			});
			var chat = new BABYLON.Sound("chat", "audio/chat.mp3", scene, function () {
				console.log("chat laoded!!");
				chat.setPosition(new BABYLON.Vector3(0, 0, -4));
				chat.play();
			}, {
				volume: 0.1,
				loop: true,
				// autoplay: true,
				spatialSound: true,
				distanceModel: "exponential",
				rolloffFactor: 1
			});

			//GAMEPLAY
			scene.onKeyboardObservable.add((kbInfo) => {
				switch (kbInfo.type) {
					case BABYLON.KeyboardEventTypes.KEYDOWN:
						console.log("KEY DOWN: ", kbInfo.event.key);
						switch (kbInfo.event.keyCode) {
							case 87: //W: Move OBJECT towards, NOT camera. TODO: create character RIG
								break;
						}
						break;
					case BABYLON.KeyboardEventTypes.KEYUP:
						console.log("KEY UP: ", kbInfo.event.keyCode);
						switch (kbInfo.event.keyCode) {
							case 87: //W: Move OBJECT towards, NOT camera. TODO: create character RIG
								break;
						}
						break;
				}
			});




			//WebXR (needs https SSL/certificate to work properly)
			// const env = scene.createDefaultEnvironment();
			const xr = await scene.createDefaultXRExperienceAsync({
				floorMeshes: [ground]
			});





			//OLD
			// xSpeed = (aDown ? -1 : 0) + (dDown ? 1 : 0);
			// zSpeed = (sDown ? -1 : 0) + (wDown ? 1 : 0);
			// camera.translate(BABYLON.Axis.X, xSpeed, BABYLON.Space.LOCAL);
			// camera.translate(BABYLON.Axis.Z, zSpeed, BABYLON.Space.LOCAL);
			// xSpeed -= brakeSpeed * engine.getDeltaTime();
			// zSpeed -= brakeSpeed * engine.getDeltaTime();



			return scene;

		};



		window.initFunction = async function () {
			var asyncEngineCreation = async function () {
				try {
					return createDefaultEngine();
				} catch (e) {
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}

			window.engine = await asyncEngineCreation();
			var jsonData = await getJson();
			if (!engine) throw 'engine should not be null.';
			if (!jsonData) throw 'Not json data!?';
			window.scene = await createScene(jsonData);
		};

		initFunction().then(() => {
			sceneToRender = scene
			engine.runRenderLoop(function () {
				if (sceneToRender && sceneToRender.activeCamera) {
					camera.position.y = 1.8;

					sceneToRender.render();
				}
			});
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});
	</script>
</body>

</html>