<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Artyste | Virtual</title>
	<!-- Babylon.js -->
	<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	<script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
	<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
	<script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script> -->

	<script src="./bjs/dat.gui.min.js"></script>
	<script src="./bjs/babylon.js"></script>
	<script src="./bjs/babylonjs.materials.min.js"></script>
	<script src="./bjs/babylonjs.loaders.js"></script>
	<script src="./bjs/babylonjs.serializers.min.js"></script>
	<script src="./bjs/babylon.gui.min.js"></script>
	<script src="./bjs/babylon.inspector.bundle.js"></script>

	<style>
		html,
		body {
			overflow: hidden;
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
		}

		#renderCanvas {
			width: 100%;
			height: 100%;
			touch-action: none;
		}
	</style>
</head>

<body>
	<canvas id="renderCanvas"></canvas>

	<script>
		// Get Variable from URL
		const queryString = window.location.search;
		const urlParams = new URLSearchParams(queryString);
		const gallery = urlParams.get('gallery');
		const url = 'https://api.artyste.info/v1/gallery/' + (gallery == null ? "starship" : gallery);

		// JSON FETCH
		var getJson = async function () {
			var jsonData;
			await fetch(url)
				.then(response => response.json())
				.then(data => {
					jsonData = data;
				}
				);
			return jsonData;
		}

		// FINISH SCENE IMPORT
		var FinishSceneImport = function () {

		}
		// GET PALCEHOLDER
		var GetPlaceholder = function (url) {
			if (placeHolderTex == null) {
				placeHolderTex = new BABYLON.Texture("./tex/placeHolder.png", scene);
			}
			placeHolderMat = new BABYLON.StandardMaterial("placeHolderMat", scene);
			placeHolderMat.diffuseTexture = placeHolderTex;
			placeHolderMat.speculartexture = placeHolderTex;
			let specColorPwr = 0.5;
			placeHolderMat.specularPower = 50;
			placeHolderMat.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);

			return placeHolderMat;
		}

		//BJS
		var canvas = document.getElementById("renderCanvas");
		var engine = null;
		var scene = null;
		var sceneToRender = null;
		var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
		var camera = null;
		var camHeight = 1.8;
		var sceneReady = false;
		var waterMat = null;
		var walkSpeed = 0.1;
		var runSpeed = 0.4;
		var walkSens = 12000;
		var runSens = 4000;
		var artName = "Asset_";
		var logoFloat = null;
		var logoSpeed = 0.2;
		var logoFloatSpeed = 0.8;
		var totalTime = 0.0;
		var deltaTime = 0.0;
		var placeHolderTex = null;
		var placeHolderMat = null;
		// var artsEmpty = [];

		const doorDist = 2;
		var wallGlass = null;
		var wallL = null;
		var wallR = null;

		var renderTarget;

		var mirrorMaterial = null;
		var mirrorMeshes = [];
		var fumeMat = null;
		var doorMat = null;


		var createScene = async function (jsonData) {

			scene = new BABYLON.Scene(engine);
			scene.clearColor = BABYLON.Color3.Black();
			scene.ambientColor = BABYLON.Color3.White();
			scene.collisionsEnabled = true;
			scene.gravity = new BABYLON.Vector3(0, -0.15, 0);


			camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1, -4), scene);
			camera.fov = 1;
			camera.checkCollisions = true;
			camera.applyGravity = true;
			camera.ellipsoid = new BABYLON.Vector3(0.4, camHeight / 2, 0.4);

			// camera.setTarget(BABYLON.Vector3.Zero());
			camera.attachControl(false);
			camera.angularSensibility = walkSens;
			camera.speed = walkSpeed;
			camera.minZ = 0.01;
			camera.keysUp = [38, 87];		//W
			camera.keysLeft = [37, 65];	//A
			camera.keysDown = [40, 83];	//S
			camera.keysRight = [39, 68];//D
			// camera.keysRotateLeft = [37];	//L
			// camera.keysRotateRight = [39];	//R
			const frameSize = 1.2;
			const frameScale = new BABYLON.Vector3(frameSize, frameSize, frameSize);


			mirrorMaterial = new BABYLON.StandardMaterial("mirror", scene);
			mirrorMaterial.reflectionTexture = new BABYLON.MirrorTexture("mirror", 1024, scene, true);
			// mirrorMaterial.reflectionTexture.mirrorPlane = reflector;
			mirrorMaterial.reflectionTexture.level = 1;

			//LIGHTS
			var dirLight = new BABYLON.HemisphericLight("dirLight", new BABYLON.Vector3(0, 1, 0), scene);
			dirLight.intensity = 0.5;
			// dirLight.diffuse = BABYLON.Color3.White();
			// dirLight.groundColor = BABYLON.Color3.Blue();
			var pLight = new BABYLON.PointLight("pLight", new BABYLON.Vector3(1, 10, 1), scene);
			pLight.intensity = 0.5;
			pLight.parent = camera;
			pLight.position = new BABYLON.Vector3(0, 0, 0);

			var refCube = BABYLON.Mesh.CreateBox("refCube", 1, scene);
			refCube.position = new BABYLON.Vector3(0, 0, 0);


			const galleryIdx = jsonData.length - 1;
			const color1 = jsonData[galleryIdx].gallery.color1 != null ? new BABYLON.Color3.FromHEXString(jsonData[galleryIdx].gallery.color1) : BABYLON.Color3.White();
			const color2 = jsonData[galleryIdx].gallery.color2 != null ? new BABYLON.Color3.FromHEXString(jsonData[galleryIdx].gallery.color2) : BABYLON.Color3.Black();
			const color3 = jsonData[galleryIdx].gallery.color3 != null ? new BABYLON.Color3.FromHEXString(jsonData[galleryIdx].gallery.color3) : BABYLON.Color3.White();

			const virtID = jsonData[galleryIdx].gallery.virtual != null ? jsonData[galleryIdx].gallery.virtual : 1;


			//LOAD MODELS
			// var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 1, segments: 4 }, scene);
			// sphere.position.y = 1;
			var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
			ground.visibility = 0;

			console.log("Virtual: " + virtID);

			if (virtID != null) {
				BABYLON.SceneLoader.ImportMesh("", "./models/", "virtual" + virtID.toString().padStart(2, '0') + ".babylon", scene, function (newMeshes) {
					newMeshes.forEach((mesh) => {
						// console.log(mesh.name);
						// console.log(mesh.position);
						mirrorMeshes.push(mesh);

						//ARTS
						if (mesh.name.indexOf(artName) > -1) {

							//FRAME
							let frame = mesh.clone();
							renderTarget.renderList.push(frame);
							mirrorMeshes.push(frame);
							frame.name = mesh.name.replace("Asset", "Frame");
							let matFrame = new BABYLON.StandardMaterial("matFrame", scene);
							matFrame.diffuseColor = color2;
							var specColorPwr = 0.3;
							matFrame.specularPower = 500;
							matFrame.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
							frame.material = matFrame;

							mesh.translate(BABYLON.Axis.Y, 0.03, BABYLON.Space.LOCAL);

							let idx = parseInt(mesh.name.substring(6)) - 1;
							if (idx < jsonData.length - 1) {

								let matArt = new BABYLON.StandardMaterial("matArt", scene);
								let texArt = new BABYLON.Texture(jsonData[idx].fileimage, scene, false, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, function () {
									var texSize = texArt.getSize();
									if (texSize.width != 0) { //malformed returns
										//Scaling ART & FRAME
										mesh.scaling = new BABYLON.Vector3(1, 0.002, texSize.height / texSize.width);
										frame.scaling = mesh.scaling;
										frame.scaling = frame.scaling.multiply(frameScale);
										frame.scaling.y = 0.02;
									}
								});
								matArt.diffuseTexture = texArt;
								matArt.speculartexture = texArt;
								var specColorPwr = 0.5;
								matArt.specularPower = 200;
								matArt.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
								mesh.material = matArt;
							}
							else {
								frame.scaling = mesh.scaling;
								frame.scaling = frame.scaling.multiply(frameScale);
								mesh.material = GetPlaceholder();
							}
						}

						//LOGO
						if (mesh.name.indexOf("GalleyLogo") > -1) {
							var matLogo = new BABYLON.StandardMaterial("matLogo", scene);
							var texLogo = new BABYLON.Texture(jsonData[jsonData.length - 1].gallery.avatar, scene);
							matLogo.diffuseTexture = texLogo;
							matLogo.speculartexture = texLogo;
							mesh.material = matLogo;
						}
						//BANNER
						if (mesh.name.indexOf("GalleyBanne") > -1) {
							var matBanner = new BABYLON.StandardMaterial("matBanner", scene);
							var texBanner = new BABYLON.Texture(jsonData[jsonData.length - 1].gallery.banner, scene);
							matBanner.diffuseTexture = texBanner;
							matBanner.speculartexture = texBanner;
							mesh.material = matBanner;
						}
						//LOGO3D
						if (mesh.name.indexOf("Logo_Float") > -1) {
							logoFloat = mesh;
						}

						if (mesh.name.indexOf("glass") > -1) {

						}
						if (mesh.name.indexOf("aterFall") > -1) {
							//WATER
							// mesh.visibility = false;
							// mesh.checkCollisions = true;
							mesh.material = waterMat;
							var waterClone = mesh.clone();
							waterClone.scaling = new BABYLON.Vector3(2, 2, 2);
							waterClone.checkCollisions = true;
							waterClone.visibility = false;
						}

						//WALLS + SCENE
						//Wall_Master Lightmaps
						if (mesh.name.indexOf("Wall_Master") > -1) {
							let mat = new BABYLON.StandardMaterial("mat_Wall_Master", scene);
							let tex = new BABYLON.Texture("./models/Wall_Master_Difuse.jpg", scene);
							mat.lightmapTexture = tex;
							mat.lightmapTexture.coordinatesIndex = 0;
							mat.useLightmapAsShadowmap = true;
							mat.ambientColor = BABYLON.Color3.White();
							// mat.specularColor = BABYLON.Color3.White();
							mesh.material = mat;

							mesh.checkCollisions = true;
						}
						if (mesh.name.indexOf("Wall_0") > -1) {
							mesh.checkCollisions = true;
						}

						//DOORS
						if (mesh.name.indexOf("Wall_Glass") > -1) {
							wallGlass = mesh;
							mesh.checkCollisions = true;
							// ApplyGlassMaterial(mesh);
							mesh.material = fumeMat;
							mesh.alphaIndex = 1001;


						}
						if (mesh.name.indexOf("Door_Glass_01_L") > -1) {
							wallL = mesh;
							mesh.material = doorMat;

						}
						if (mesh.name.indexOf("Door_Glass_01_R") > -1) {
							wallR = mesh;
							mesh.material = doorMat;
							// console.log(mesh.alphaIndex);
							// mesh.alphaIndex = 999;
						}


						if (mesh.name.indexOf("Start") > -1) {
							mesh.position = new BABYLON.Vector3(mesh.position.x, camHeight, mesh.position.z);
							mesh.translate(BABYLON.Axis.Z, -4, BABYLON.Space.LOCAL);
							camera.position = mesh.position;
						}


						//ALL MESHES
						if (mesh.name.indexOf("aterFall") < 0) {
							renderTarget.renderList.push(mesh);
						}

						if (mesh.name.indexOf("Wall_Glass") < 0 && mesh.name.indexOf("Door_Glass_01_L") < 0 && mesh.name.indexOf("Door_Glass_01_R") < 0) {
							// mirrorMaterial.reflectionTexture.renderList.push(mesh);
						}
					});


					// Skybox
					var skybox = BABYLON.Mesh.CreateBox("skyBox", 1000.0, scene);
					var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
					skyboxMaterial.backFaceCulling = false;
					skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("https://playground.babylonjs.com/textures/TropicalSunnyDay", scene);
					skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
					skyboxMaterial.diffuseColor = new BABYLON.Color3.Black();
					skyboxMaterial.specularColor = new BABYLON.Color3.Black();
					skyboxMaterial.disableLighting = true;
					skybox.material = skyboxMaterial;
					renderTarget.renderList.push(skybox);






					//Creation of a glass planes
					var smokeMirror = BABYLON.MeshBuilder.CreatePlane("smokeMirror", { width: 20, height: 20 }, scene);
					smokeMirror.position = new BABYLON.Vector3(23, 6.4, 10);
					smokeMirror.rotation = new BABYLON.Vector3(270 / 180 * Math.PI, 0, 60 / 180 * Math.PI);

					//Ensure working with new values for smokeMirror by computing and obtaining its worldMatrix
					smokeMirror.computeWorldMatrix(true);
					var smokeMirror_worldMatrix = smokeMirror.getWorldMatrix();

					//Obtain normals for plane and assign one of them as the normal
					var smokeMirror_vertexData = smokeMirror.getVerticesData("normal");
					var smokeMirrorNormal = new BABYLON.Vector3(smokeMirror_vertexData[0], smokeMirror_vertexData[1], smokeMirror_vertexData[2]);
					//Use worldMatrix to transform normal into its current value
					smokeMirrorNormal = new BABYLON.Vector3.TransformNormal(smokeMirrorNormal, smokeMirror_worldMatrix)

					//Create reflecting surface for smokeMirror surface
					var reflector = new BABYLON.Plane.FromPositionAndNormal(smokeMirror.position, smokeMirrorNormal.scale(-1));

					//Create the smokeMirror material
					var smokeMirrorMaterial = new BABYLON.StandardMaterial("smokeMirror", scene);
					smokeMirrorMaterial.reflectionTexture = new BABYLON.MirrorTexture("smokeMirror", 1024, scene, true);
					smokeMirrorMaterial.reflectionTexture.mirrorPlane = reflector;
					for (let index = 0; index < mirrorMeshes.length; index++) {
						const element = mirrorMeshes[index];
						smokeMirrorMaterial.reflectionTexture.renderList.push(element);
						// console.log(index);
					}
					smokeMirrorMaterial.reflectionTexture.level = 0.15;
					smokeMirrorMaterial.diffuseColor = BABYLON.Color3.Black();

					smokeMirror.material = smokeMirrorMaterial;









					FinishSceneImport();
				});

			}

			//LOAD AUDIO
			var music = new BABYLON.Sound("music", "audio/music.mp3", scene, function () {
				console.log("music laoded!!");
				music.setPosition(new BABYLON.Vector3(0, 2, 0));
				music.play();
			}, {
				volume: 0.8,
				loop: true,
				autoplay: true,
				spatialSound: true,
				distanceModel: "exponential",
				rolloffFactor: 0.4
			});
			var chat = new BABYLON.Sound("chat", "audio/chat.mp3", scene, function () {
				console.log("chat laoded!!");
				chat.setPosition(new BABYLON.Vector3(-10, 5, 0));
				chat.play();
			}, {
				volume: 0.5,
				loop: true,
				autoplay: true,
				spatialSound: true,
				distanceModel: "exponential",
				rolloffFactor: 0.5
			});

			//GAMEPLAY
			scene.onKeyboardObservable.add((kbInfo) => {
				switch (kbInfo.type) {
					case BABYLON.KeyboardEventTypes.KEYDOWN:
						console.log("KEY DOWN: ", kbInfo.event.key);
						switch (kbInfo.event.keyCode) {
							case 87: //W: Move OBJECT towards, NOT camera. TODO: create character RIG
								break;
							case 16:
								camera.speed = runSpeed;
								camera.angularSensibility = runSens;
								break;
							case 119:
								scene.debugLayer.show();
								break;
							case 120:
								scene.debugLayer.hide();
								break;
						}
						break;
					case BABYLON.KeyboardEventTypes.KEYUP:
						console.log("KEY UP: ", kbInfo.event.keyCode);
						switch (kbInfo.event.keyCode) {
							case 87: //W: Move OBJECT towards, NOT camera. TODO: create character RIG
								break;
							case 16:
								camera.speed = walkSpeed;
								camera.angularSensibility = walkSens;
								break;
						}
						break;
				}
			});


			//WebXR (needs https SSL/certificate to work properly)
			// const env = scene.createDefaultEnvironment();
			const xr = await scene.createDefaultXRExperienceAsync({
				floorMeshes: [ground]
			});


			//OLD
			// xSpeed = (aDown ? -1 : 0) + (dDown ? 1 : 0);
			// zSpeed = (sDown ? -1 : 0) + (wDown ? 1 : 0);
			// camera.translate(BABYLON.Axis.X, xSpeed, BABYLON.Space.LOCAL);
			// camera.translate(BABYLON.Axis.Z, zSpeed, BABYLON.Space.LOCAL);
			// xSpeed -= brakeSpeed * engine.getDeltaTime();
			// zSpeed -= brakeSpeed * engine.getDeltaTime();

			//SHADERS & MATERIALS
			BABYLON.Effect.ShadersStore["waterVertexShader"] = `   
				precision highp float;

				attribute vec3 position;
				attribute vec3 normal;
				attribute vec2 uv;
				
				uniform mat4 world;
				uniform mat4 worldView;
				uniform mat4 worldViewProjection;
				uniform mat4 view;
				uniform mat4 projection;
				uniform float time;

				varying vec2 vUV;
				varying vec2 vSP;

				void main(void) {

					// vec4 posW = dModelMatrix * vec4(localPos, 1.0);
					vec4 posW = worldViewProjection * vec4(position, 1.0);
					
					// posW.zw = vec2(0.0, 1.0);
					


					vec4 screenPos;
					
						screenPos = vec4(uv.xy * 2.0 - 1.0, 0.5, 1);
									
						screenPos = view * posW;
					


					vec3 p = position;
					// p.x = p.x + sin(2.0 * position.y + time*5.);
					// p.y = p.y + sin(time*5. + 4.0);

					gl_Position = worldViewProjection * vec4(p, 1.0);
					
					vec3 ndc = gl_Position.xyz / gl_Position.w;
					vec2 viewportCoord = ndc.xy * 0.5 + 0.5; //ndc is -1 to 1 in GL. scale for 0 to 1
					vec2 viewportPixelCoord = viewportCoord * vec2(1, 1);
					
					vUV = uv;
					vSP = viewportPixelCoord;
				}`;

			BABYLON.Effect.ShadersStore["waterFragmentShader"] = `
				precision highp float;
				
				uniform sampler2D texTarget;
				uniform sampler2D texNormal;
				uniform float time;
				uniform mat4 world;
				uniform mat4 worldView;
				uniform mat4 worldViewProjection;
				uniform mat4 view;
				uniform mat4 projection;

				varying vec2 vUV;
				varying vec2 vSP;

				void main(void) {
					vec2 vSP = vSP;
					vec4 normTex = texture2D(texNormal, vec2(5.*vUV.x, 1.*vUV.y+time*0.5));
					// vSP.y += time*2.;
					vSP.x += (normTex.x-0.5) *0.1;
					vSP.y += (normTex.y-0.5) *0.1;
					// vSP.x += texture2D(texNormal, vSP).x;
					gl_FragColor = texture2D(texTarget, vSP);
					// gl_FragColor.z = 1.0 - gl_FragColor.z;
					gl_FragColor.a = 1.0;
					gl_FragColor.g += 0.05;
					gl_FragColor.b += 0.15;
    		}`;

			waterMat = new BABYLON.ShaderMaterial("shader", scene, {
				vertex: "water",
				fragment: "water",
			},
				{
					attributes: ["position", "normal", "uv"],
					uniforms: ["world", "worldView", "worldViewProjection", "view", "projection, time"],
					needAlphaBlending: true,
				});
			renderTarget = new BABYLON.RenderTargetTexture("scene", 1024, scene, true);
			renderTarget.lodGenerationScale = 0.5;
			renderTarget.depth = 0.5;
			renderTarget.wrapU = 2;
			renderTarget.wrapV = 2;
			scene.customRenderTargets.push(renderTarget);
			waterMat.setTexture("texTarget", renderTarget);
			waterMat.setTexture("texNormal", new BABYLON.Texture("./tex/waterbump.png", scene));


			fumeMat = new BABYLON.StandardMaterial("fumeMat", scene);
			fumeMat.diffuseColor = BABYLON.Color3.Black();
			var specColorPwr = 0.2;
			fumeMat.specularPower = 500;
			fumeMat.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
			fumeMat.alpha = 0.9;

			doorMat = new BABYLON.StandardMaterial("doorMat", scene);
			doorMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.0);
			var specColorPwr = 1;
			doorMat.specularPower = 500;
			doorMat.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
			doorMat.alpha = 0.6;










			return scene;

		};



		window.initFunction = async function () {
			var asyncEngineCreation = async function () {
				try {
					return createDefaultEngine();
				} catch (e) {
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}

			window.engine = await asyncEngineCreation();
			var jsonData = await getJson();
			if (!engine) throw 'engine should not be null.';
			if (!jsonData) throw 'Not json data!?';
			window.scene = await createScene(jsonData);
		};

		initFunction().then(() => {
			sceneToRender = scene
			engine.runRenderLoop(function () {
				if (sceneToRender && sceneToRender.activeCamera) {
					deltaTime = engine.getDeltaTime() * 0.001;
					totalTime += deltaTime;
					// camera.position.y = 1.8;

					if (logoFloat != null) {
						logoFloat.rotate(BABYLON.Axis.Y, Math.PI * deltaTime * logoSpeed, BABYLON.Space.WORLD);
						logoFloat.position = new BABYLON.Vector3(logoFloat.position.x, 3 + Math.sin(totalTime * logoFloatSpeed) * 0.5, logoFloat.position.z);
					}

					//WALLS
					if (wallL != null && wallR != null && wallGlass != null) {
						wallL.position = new BABYLON.Vector3(
							-doorDist + BABYLON.Scalar.Clamp((BABYLON.Vector3.Distance(camera.position, wallGlass.position) - 4), 0, doorDist),
							wallL.position.y,
							wallL.position.z);
						wallR.position = new BABYLON.Vector3(
							-wallL.position.x,
							wallR.position.y,
							wallR.position.z);
					}


					waterMat.setFloat("time", totalTime);


					// console.log(camera.position.y)

					sceneToRender.render();
				}
			});
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});
	</script>
</body>

</html>