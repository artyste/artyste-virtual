<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Artyste | Virtual</title>
	<!-- Babylon.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
	<!-- <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script> -->
	<!-- <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script> -->
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	<!-- <script src="https://cdn.babylonjs.com/loaders/babylonjs.glTFFileLoader.js"></script> -->
	<script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
	<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
	<script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

	<style>
		html,
		body {
			overflow: hidden;
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
		}

		#renderCanvas {
			width: 100%;
			height: 100%;
			touch-action: none;
		}
	</style>
</head>

<body>
	<canvas id="renderCanvas"></canvas>

	<script>
		// Get Variable from URL
		const queryString = window.location.search;
		const urlParams = new URLSearchParams(queryString);
		const gallery = urlParams.get('gallery');
		const url = 'https://api.artyste.info/v1/gallery/' + gallery;

		// JSON FETCH
		var getJson = async function () {
			var jsonData;
			await fetch(url)
				.then(response => response.json())
				.then(data => {
					jsonData = data;
				}
				);
			return jsonData;
		}

		// FINISH SCENE IMPORT
		var FinishSceneImport = function () {

		}
		// GET PALCEHOLDER
		var GetPlaceholder = function (url) {
			if (placeHolderTex == null) {
				placeHolderTex = new BABYLON.Texture("./tex/placeHolder.png", scene);
			}
			placeHolderMat = new BABYLON.StandardMaterial("placeHolderMat", scene);
			placeHolderMat.diffuseTexture = placeHolderTex;
			placeHolderMat.speculartexture = placeHolderTex;
			let specColorPwr = 0.5;
			placeHolderMat.specularPower = 50;
			placeHolderMat.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);

			return placeHolderMat;
		}

		//BJS
		var canvas = document.getElementById("renderCanvas");
		var engine = null;
		var scene = null;
		var sceneToRender = null;
		var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
		var camera = null;
		var sceneReady = false;
		var waterMat = null;
		var walkSpeed = 0.05;
		var runSpeed = 0.3;
		var walkSens = 15000;
		var runSens = 5000;
		var artName = "Asset_";
		var logoFloat = null;
		var logoSpeed = 0.2;
		var logoFloatSpeed = 0.8;
		var totalTime = 0.0;
		var deltaTime = 0.0;
		var placeHolderTex = null;
		var placeHolderMat = null;
		// var artsEmpty = [];


		var createScene = async function (jsonData) {

			scene = new BABYLON.Scene(engine);
			scene.clearColor = BABYLON.Color3.Black();

			camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1, -4), scene);
			// camera.setTarget(BABYLON.Vector3.Zero());
			camera.attachControl(false);
			camera.angularSensibility = walkSens;
			camera.speed = walkSpeed;
			camera.minZ = 0.01;
			camera.keysUp = [38, 87];		//W
			camera.keysLeft = [37, 65];	//A
			camera.keysDown = [40, 83];	//S
			camera.keysRight = [39, 68];//D
			// camera.keysRotateLeft = [37];	//L
			// camera.keysRotateRight = [39];	//R
			const frameSize = 1.2;
			const frameScale = new BABYLON.Vector3(frameSize, frameSize, frameSize);

			//LIGHTS
			var dirLight = new BABYLON.HemisphericLight("dirLight", new BABYLON.Vector3(0, 1, -1), scene);
			dirLight.intensity = 0.5;
			var pLight = new BABYLON.PointLight("pLight", new BABYLON.Vector3(1, 10, 1), scene);
			pLight.intensity = 0.5;
			pLight.parent = camera;
			pLight.position = new BABYLON.Vector3(0, 0, 0);


			const galleryIdx = jsonData.length - 1;
			const color1 = jsonData[galleryIdx].gallery.color1 != null ? new BABYLON.Color3.FromHEXString(jsonData[galleryIdx].gallery.color1) : BABYLON.Color3.White();
			const color2 = jsonData[galleryIdx].gallery.color2 != null ? new BABYLON.Color3.FromHEXString(jsonData[galleryIdx].gallery.color2) : BABYLON.Color3.Black();
			const color3 = jsonData[galleryIdx].gallery.color3 != null ? new BABYLON.Color3.FromHEXString(jsonData[galleryIdx].gallery.color3) : BABYLON.Color3.White();

			const virtID = jsonData[galleryIdx].gallery.virtual != null ? jsonData[galleryIdx].gallery.virtual : 1;


			//LOAD MODELS
			// var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 1, segments: 4 }, scene);
			// sphere.position.y = 1;
			var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
			ground.visibility = 0;

			console.log("Virtual: " + virtID);

			if (virtID != null) {
				BABYLON.SceneLoader.ImportMesh("", "./models/", "virtual" + virtID.toString().padStart(2, '0') + ".babylon", scene, function (newMeshes) {
					newMeshes.forEach((mesh) => {
						// console.log(mesh.name);
						// console.log(mesh.position);

						//ARTS
						if (mesh.name.indexOf(artName) > -1) {

							//FRAME
							let frame = mesh.clone();
							frame.name = mesh.name.replace("Asset", "Frame");
							let matFrame = new BABYLON.StandardMaterial("matFrame", scene);
							matFrame.diffuseColor = color2;
							var specColorPwr = 0.3;
							matFrame.specularPower = 500;
							matFrame.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
							frame.material = matFrame;

							mesh.translate(BABYLON.Axis.Y, 0.03, BABYLON.Space.LOCAL);

							let idx = parseInt(mesh.name.substring(6)) - 1;
							if (idx < jsonData.length - 1) {

								let matArt = new BABYLON.StandardMaterial("matArt", scene);
								let texArt = new BABYLON.Texture(jsonData[idx].fileimage, scene, false, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, function () {
									var texSize = texArt.getSize();
									if (texSize.width != 0) { //malformed returns
										//Scaling ART & FRAME
										mesh.scaling = new BABYLON.Vector3(1, 0.002, texSize.height / texSize.width);
										frame.scaling = mesh.scaling;
										frame.scaling = frame.scaling.multiply(frameScale);
										frame.scaling.y = 0.02;
									}
								});
								matArt.diffuseTexture = texArt;
								matArt.speculartexture = texArt;
								var specColorPwr = 0.5;
								matArt.specularPower = 200;
								matArt.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
								mesh.material = matArt;
							}
							else {
								frame.scaling = mesh.scaling;
								frame.scaling = frame.scaling.multiply(frameScale);
								mesh.material = GetPlaceholder();
							}
						}

						//LOGO
						if (mesh.name.indexOf("GalleyLogo") > -1) {
							var matLogo = new BABYLON.StandardMaterial("matLogo", scene);
							var texLogo = new BABYLON.Texture(jsonData[jsonData.length - 1].gallery.avatar, scene);
							matLogo.diffuseTexture = texLogo;
							matLogo.speculartexture = texLogo;
							mesh.material = matLogo;
						}
						//BANNER
						if (mesh.name.indexOf("GalleyBanne") > -1) {
							var matBanner = new BABYLON.StandardMaterial("matBanner", scene);
							var texBanner = new BABYLON.Texture(jsonData[jsonData.length - 1].gallery.banner, scene);
							matBanner.diffuseTexture = texBanner;
							matBanner.speculartexture = texBanner;
							mesh.material = matBanner;
						}

						if (mesh.name.indexOf("Logo_Float") > -1) {
							logoFloat = mesh;
						}

						if (mesh.name.indexOf("glass") > -1) {

						}
						if (mesh.name.indexOf("aterFall") > -1) {
							//WATER

							mesh.visibility = false;
						}

					});


					// Skybox
					var skybox = BABYLON.Mesh.CreateBox("skyBox", 1000.0, scene);
					var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
					skyboxMaterial.backFaceCulling = false;
					skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("https://playground.babylonjs.com/textures/TropicalSunnyDay", scene);
					skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
					skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
					skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
					skyboxMaterial.disableLighting = true;
					skybox.material = skyboxMaterial;


					FinishSceneImport();
				});

			}

			//LOAD AUDIO
			var music = new BABYLON.Sound("music", "audio/music.mp3", scene, function () {
				console.log("music laoded!!");
				music.setPosition(new BABYLON.Vector3(0, 0, 2));
				music.play();
			}, {
				volume: 0.8,
				loop: true,
				// autoplay: true,
				spatialSound: true,
				distanceModel: "exponential",
				rolloffFactor: 0.4
			});
			var chat = new BABYLON.Sound("chat", "audio/chat.mp3", scene, function () {
				console.log("chat laoded!!");
				chat.setPosition(new BABYLON.Vector3(0, 0, -4));
				chat.play();
			}, {
				volume: 0.1,
				loop: true,
				// autoplay: true,
				spatialSound: true,
				distanceModel: "exponential",
				rolloffFactor: 1
			});

			//GAMEPLAY
			scene.onKeyboardObservable.add((kbInfo) => {
				switch (kbInfo.type) {
					case BABYLON.KeyboardEventTypes.KEYDOWN:
						console.log("KEY DOWN: ", kbInfo.event.key);
						switch (kbInfo.event.keyCode) {
							case 87: //W: Move OBJECT towards, NOT camera. TODO: create character RIG
								break;
							case 16:
								camera.speed = runSpeed;
								camera.angularSensibility = runSens;
								break;
							case 119:
								scene.debugLayer.show();
								break;
							case 120:
								scene.debugLayer.hide();
								break;
						}
						break;
					case BABYLON.KeyboardEventTypes.KEYUP:
						console.log("KEY UP: ", kbInfo.event.keyCode);
						switch (kbInfo.event.keyCode) {
							case 87: //W: Move OBJECT towards, NOT camera. TODO: create character RIG
								break;
							case 16:
								camera.speed = walkSpeed;
								camera.angularSensibility = walkSens;
								break;
						}
						break;
				}
			});




			//WebXR (needs https SSL/certificate to work properly)
			// const env = scene.createDefaultEnvironment();
			const xr = await scene.createDefaultXRExperienceAsync({
				floorMeshes: [ground]
			});





			//OLD
			// xSpeed = (aDown ? -1 : 0) + (dDown ? 1 : 0);
			// zSpeed = (sDown ? -1 : 0) + (wDown ? 1 : 0);
			// camera.translate(BABYLON.Axis.X, xSpeed, BABYLON.Space.LOCAL);
			// camera.translate(BABYLON.Axis.Z, zSpeed, BABYLON.Space.LOCAL);
			// xSpeed -= brakeSpeed * engine.getDeltaTime();
			// zSpeed -= brakeSpeed * engine.getDeltaTime();



			return scene;

		};



		window.initFunction = async function () {
			var asyncEngineCreation = async function () {
				try {
					return createDefaultEngine();
				} catch (e) {
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}

			window.engine = await asyncEngineCreation();
			var jsonData = await getJson();
			if (!engine) throw 'engine should not be null.';
			if (!jsonData) throw 'Not json data!?';
			window.scene = await createScene(jsonData);
		};

		initFunction().then(() => {
			sceneToRender = scene
			engine.runRenderLoop(function () {
				if (sceneToRender && sceneToRender.activeCamera) {
					deltaTime = engine.getDeltaTime() * 0.001;
					totalTime += deltaTime;
					camera.position.y = 1.8;

					if (logoFloat != null) {
						logoFloat.rotate(BABYLON.Axis.Y, Math.PI * deltaTime * logoSpeed, BABYLON.Space.WORLD);
						logoFloat.position = new BABYLON.Vector3(logoFloat.position.x, 3 + Math.sin(totalTime * logoFloatSpeed) * 0.5, logoFloat.position.z);
					}


					sceneToRender.render();
				}
			});
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});
	</script>
</body>

</html>