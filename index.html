<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Artyste|Virtual</title>
	<!-- Babylon.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
	<!-- <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script> -->
	<!-- <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script> -->
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	<!-- <script src="https://cdn.babylonjs.com/loaders/babylonjs.glTFFileLoader.js"></script> -->
	<script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
	<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
	<script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

	<style>
		html,
		body {
			overflow: hidden;
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
		}

		#renderCanvas {
			width: 100%;
			height: 100%;
			touch-action: none;
		}
	</style>
</head>

<body>
	<canvas id="renderCanvas"></canvas>

	<script>
		// Get Variable from URL
		const queryString = window.location.search;
		const urlParams = new URLSearchParams(queryString);
		const gallery = urlParams.get('gallery');
		const url = 'https://api.arthology.io/v1/gallery/' + gallery;

		// JSON FETCH
		var getJson = async function () {
			var jsonData;
			await fetch(url)
				.then(response => response.json())
				.then(data => {
					jsonData = data;
				}
				);
			return jsonData;
		}

		//BJS
		var canvas = document.getElementById("renderCanvas");
		var engine = null;
		var scene = null;
		var sceneToRender = null;
		var camera = null;
		var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };

		var createScene = async function (jsonData) {

			var scene = new BABYLON.Scene(engine);
			scene.clearColor = BABYLON.Color3.Black();
			// scene.debugLayer.show();

			camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1, -4), scene);
			// camera.setTarget(BABYLON.Vector3.Zero());
			camera.attachControl(false);
			camera.angularSensibility = 15000;
			camera.speed = 0.05;
			camera.minZ = 0.01;
			camera.keysUp = [38, 87];		//W
			camera.keysLeft = [37, 65];	//A
			camera.keysDown = [40, 83];	//S
			camera.keysRight = [39, 68];//D


			var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, -1), scene);
			light.intensity = 0.8;

			// LOAD ARTS
			var arts = [];
			for (let i = 0; i < jsonData.length; i++) {
				if (i == jsonData.length - 1) { //gallery avatar&banner
					console.log(jsonData[i].gallery.name);

					const planeAvatar = BABYLON.MeshBuilder.CreatePlane("planeAvatar",
						{ height: 2, width: 2 });
					planeAvatar.position.x = 1;
					planeAvatar.position.y = 1;
					planeAvatar.position.z = 1.99;
					var matAvatar = new BABYLON.StandardMaterial("matAvatar", scene);
					var texAvatar = new BABYLON.Texture(jsonData[i].gallery.avatar, scene);
					matAvatar.diffuseTexture = texAvatar;
					matAvatar.speculartexture = texAvatar;
					planeAvatar.material = matAvatar;

					const planeBanner = BABYLON.MeshBuilder.CreatePlane("planeBanner",
						{ height: 1, width: 4 });
					planeBanner.position.x = 0;
					planeBanner.position.y = 2.5;
					planeBanner.position.z = 1.98;
					var matBanner = new BABYLON.StandardMaterial("matBanner", scene);
					var texBanner = new BABYLON.Texture(jsonData[i].gallery.banner, scene);
					matBanner.diffuseTexture = texBanner;
					matBanner.speculartexture = texBanner;
					let specColorPwr = 1;
					matBanner.specularPower = 50;
					matBanner.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
					planeBanner.material = matBanner;

				}
				else { //arts
					console.log(jsonData[i].title);
					const planeArt = BABYLON.MeshBuilder.CreatePlane("planeArt",
						{ height: 0.8, width: 0.8 });
					planeArt.position.x = -1 + i;
					planeArt.position.y = 0.5;
					planeArt.position.z = -0.5;
					planeArt.rotation = new BABYLON.Vector3(0.45 * Math.PI / 2, 0, 0);

					var matArt = new BABYLON.StandardMaterial("matArt", scene);
					let texArt = new BABYLON.Texture(jsonData[i].fileimage, scene, false, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, function () {
						var texSize = texArt.getSize();
						if (texSize.width != 0) { //malformed returns
							planeArt.scaling = new BABYLON.Vector3(1, texSize.height / texSize.width, 1);
						}
					});
					matArt.diffuseTexture = texArt;
					matArt.speculartexture = texArt;
					let specColorPwr = 0.5;
					matArt.specularPower = 200;
					matArt.specularColor = new BABYLON.Color3(specColorPwr, specColorPwr, specColorPwr);
					planeArt.material = matArt;
				}
			}


			//LOAD MODELS
			// var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 1, segments: 4 }, scene);
			// sphere.position.y = 1;
			var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
			ground.visibility = 0;

			BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/CornellBox/", "cornellBox.glb", scene, function (newMeshes) {
				newMeshes[0].rotationQuaternion = null;
				newMeshes[0].rotation.y = 0;

				scene.getMaterialByName("light.000").emissiveColor = BABYLON.Color3.White();

				/* lightmaps assignation */

				// we have to cycles through objects to assign their lightmaps
				const lightmappedMeshes = ["bloc.000", "suzanne.000", "cornellBox.000"];

				lightmappedMeshes.forEach((meshName) => {
					// lightmap texture creation
					let currentLightmap = new BABYLON.Texture(
						"https://models.babylonjs.com/CornellBox/" + meshName + ".lightmap.jpg",
						scene,
						null,
						false);
					currentLightmap.onLoadObservable.addOnce(function (tex) {
						currentLightmap.name = meshName + "-lightmap";
						newMeshes.forEach((mesh) => {
							if (mesh.name.indexOf(meshName) != -1) {
								mesh.material.lightmapTexture = currentLightmap;
								mesh.material.lightmapTexture.coordinatesIndex = 1;
								mesh.material.useLightmapAsShadowmap = true;
							}
						});
					});
				});

			});

			//LOAD AUDIO
			var music = new BABYLON.Sound("music", "audio/music.mp3", scene, function () {
				console.log("music laoded!!");
				music.setPosition(new BABYLON.Vector3(0, 0, 2));
				music.play();
			}, {
				volume: 0.8,
				loop: true,
				// autoplay: true,
				spatialSound: true,
				distanceModel: "exponential",
				rolloffFactor: 0.4
			});
			var chat = new BABYLON.Sound("chat", "audio/chat.mp3", scene, function () {
				console.log("chat laoded!!");
				chat.setPosition(new BABYLON.Vector3(0, 0, -4));
				chat.play();
			}, {
				volume: 0.1,
				loop: true,
				// autoplay: true,
				spatialSound: true,
				distanceModel: "exponential",
				rolloffFactor: 1
			});

			//GAMEPLAY
			scene.onKeyboardObservable.add((kbInfo) => {
				switch (kbInfo.type) {
					case BABYLON.KeyboardEventTypes.KEYDOWN:
						console.log("KEY DOWN: ", kbInfo.event.key);
						switch (kbInfo.event.keyCode) {
							case 87: //W: Move OBJECT towards, NOT camera. TODO: create character RIG
								break;
						}
						break;
					case BABYLON.KeyboardEventTypes.KEYUP:
						console.log("KEY UP: ", kbInfo.event.keyCode);
						switch (kbInfo.event.keyCode) {
							case 87: //W: Move OBJECT towards, NOT camera. TODO: create character RIG
								break;
						}
						break;
				}
			});




			//XR
			// const env = scene.createDefaultEnvironment();
			const xr = await scene.createDefaultXRExperienceAsync({
				floorMeshes: [ground]
			});





			//OLD
			// xSpeed = (aDown ? -1 : 0) + (dDown ? 1 : 0);
			// zSpeed = (sDown ? -1 : 0) + (wDown ? 1 : 0);
			// camera.translate(BABYLON.Axis.X, xSpeed, BABYLON.Space.LOCAL);
			// camera.translate(BABYLON.Axis.Z, zSpeed, BABYLON.Space.LOCAL);
			// xSpeed -= brakeSpeed * engine.getDeltaTime();
			// zSpeed -= brakeSpeed * engine.getDeltaTime();



			return scene;

		};



		window.initFunction = async function () {
			var asyncEngineCreation = async function () {
				try {
					return createDefaultEngine();
				} catch (e) {
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}

			window.engine = await asyncEngineCreation();
			var jsonData = await getJson();
			if (!engine) throw 'engine should not be null.';
			if (!jsonData) throw 'Not json data!?';
			window.scene = await createScene(jsonData);
		};

		initFunction().then(() => {
			sceneToRender = scene
			engine.runRenderLoop(function () {
				if (sceneToRender && sceneToRender.activeCamera) {
					camera.position.y = 1;

					sceneToRender.render();
				}
			});
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});
	</script>
</body>

</html>